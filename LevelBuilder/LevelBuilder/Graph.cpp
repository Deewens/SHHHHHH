#include "Graph.h"

/**
 * Pathfinding using UCS Algorithm
 *
 * @tparam NodeType
 * @tparam ArcType
 * @param start Graph node indicating the origin of the search
 * @param goal goal vertex indicating the destination of the search
 * @param f_visit function that outputs the node currently being expanded (i.e. the node at the top of the priority queue).
 * @param path container (a vector) which holds the best path generated by the algorithm’s completion
 */
template<class NodeType, class ArcType>
void Graph<NodeType, ArcType>::ucs(Graph::Node* start, Graph::Node* goal, std::function<void(Node*)> f_visit,
    std::vector<Node*>& path)
{
    if (start == nullptr || goal == nullptr) return;

    std::priority_queue<Node*, std::vector<Node*>, NodeComparer<NodeType, ArcType>> pq;

    for (int i = 0; i < m_nodes.size(); i++)
    {
        m_nodes.at(i)->m_data.cost = -1;
        m_nodes.at(i)->setPrevious(nullptr);
    }

    start->m_data.cost = 0;

    pq.push(start);
    start->setMarked(true);

    while (!pq.empty() && pq.top() != goal)
    {
        auto it = pq.top()->arcList().begin();
        auto endIt = pq.top()->arcList().end();

        for (; it != endIt; it++)
        {
            //Arc *arc = it;
            Node* child = it->node();
            if (child != pq.top()->previous())
            {
                int arcWeight = it->weight();
                int distToChild = arcWeight + pq.top()->m_data.cost;

                if (distToChild < child->m_data.cost || child->m_data.cost == -1)
                {
                    (*it).node()->m_data.cost = distToChild;
                    (*it).node()->setPrevious(pq.top());
                }

                if (!child->marked())
                {
                    pq.push(child);
                    child->setMarked(true);
                }
            }
        }
        pq.pop();
    }

    Node* temp = goal;

    for (; temp != nullptr; temp = temp->previous())
    {
        path.push_back(temp);
    }
}